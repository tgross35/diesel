<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits related to relationships between multiple tables."><meta name="keywords" content="rust, rustlang, rust-lang, associations"><title>diesel::associations - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../diesel/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../diesel/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module associations</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#traits">Traits</a></li><li><a href="#derives">Derive Macros</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../diesel/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../index.html">diesel</a>::<wbr><a class="mod" href="#">associations</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/diesel/associations/mod.rs.html#1-412">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits related to relationships between multiple tables.</p>
<p>Associations in Diesel are always child-to-parent.
You can declare an association between two records with <code>#[diesel(belongs_to)]</code>.
Unlike other ORMs, Diesel has no concept of <code>has many</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>schema::{posts, users};

<span class="attribute">#[derive(Identifiable, Queryable, PartialEq, Debug)]
#[diesel(table_name = users)]
</span><span class="kw">pub struct </span>User {
    id: i32,
    name: String,
}

<span class="attribute">#[derive(Identifiable, Queryable, Associations, PartialEq, Debug)]
#[diesel(belongs_to(User))]
#[diesel(table_name = posts)]
</span><span class="kw">pub struct </span>Post {
    id: i32,
    user_id: i32,
    title: String,
}

<span class="kw">let </span>user = users.find(<span class="number">2</span>).get_result::&lt;User&gt;(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>users_post = Post::belonging_to(<span class="kw-2">&amp;</span>user)
    .first(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = Post { id: <span class="number">3</span>, user_id: <span class="number">2</span>, title: <span class="string">&quot;My first post too&quot;</span>.into() };
<span class="macro">assert_eq!</span>(expected, users_post);</code></pre></div>
<p>Note that in addition to the <code>#[diesel(belongs_to)]</code> annotation, we also need to
<code>#[derive(Associations)]</code></p>
<p><code>#[diesel(belongs_to)]</code> is given the name of the struct that represents the parent.
Both the parent and child must implement <a href="../prelude/trait.Identifiable.html" title="Identifiable"><code>Identifiable</code></a>.
The struct given to <code>#[diesel(belongs_to)]</code> must be in scope,
so you will need <code>use some_module::User</code> if <code>User</code> is defined in another module.</p>
<p>If the parent record is generic over lifetimes, they can be written as <code>'_</code>.
You will also need to wrap the type in quotes until
<code>unrestricted_attribute_tokens</code> is stable.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[derive(Identifiable)]
#[diesel(table_name = users)]
</span><span class="kw">pub struct </span>User&lt;<span class="lifetime">&#39;a</span>&gt; {
    id: i32,
    name: Cow&lt;<span class="lifetime">&#39;a</span>, str&gt;,
}

<span class="attribute">#[derive(Associations)]
#[diesel(belongs_to(User&lt;<span class="lifetime">&#39;_</span>&gt;))]
#[diesel(table_name = posts)]
</span><span class="kw">pub struct </span>Post {
    id: i32,
    user_id: i32,
    title: String,
}</code></pre></div>
<p>By default, Diesel assumes that your foreign keys will follow the convention <code>table_name_id</code>.
If your foreign key has a different name,
you can provide the <code>foreign_key</code> argument to <code>#[diesel(belongs_to)]</code>.
For example, <code>#[diesel(belongs_to(Foo, foreign_key = mykey))]</code>.</p>
<p>Associated data is typically loaded in multiple queries (one query per table).
This is usually more efficient than using a join,
especially if 3 or more tables are involved.
For most datasets,
using a join to load in a single query transmits so much duplicate data
that it costs more time than the extra round trip would have.</p>
<p>You can load the children for one or more parents using
<a href="../query_dsl/trait.BelongingToDsl.html#tymethod.belonging_to"><code>belonging_to</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>user = users.find(<span class="number">1</span>).first::&lt;User&gt;(connection).expect(<span class="string">&quot;Error loading user&quot;</span>);
<span class="kw">let </span>post_list = Post::belonging_to(<span class="kw-2">&amp;</span>user)
    .load::&lt;Post&gt;(connection)
    .expect(<span class="string">&quot;Error loading posts&quot;</span>);
<span class="kw">let </span>expected = <span class="macro">vec!</span>[
    Post { id: <span class="number">1</span>, user_id: <span class="number">1</span>, title: <span class="string">&quot;My first post&quot;</span>.to_string() },
    Post { id: <span class="number">2</span>, user_id: <span class="number">1</span>, title: <span class="string">&quot;About Rust&quot;</span>.to_string() },
];

<span class="macro">assert_eq!</span>(post_list, expected);</code></pre></div>
<p>If you’re coming from other ORMs, you’ll notice that this design is quite different from most.
There you would have an instance method on the parent, or have the children stored somewhere on
the posts. This design leads to many problems, including <a href="https://stackoverflow.com/q/97197/1254484">N+1 query
bugs</a>, and runtime errors when accessing an
association that isn’t there.</p>
<p>In Diesel, data and its associations are considered to be separate. If you want to pass around
a user and all of its posts, that type is <code>(User, Vec&lt;Post&gt;)</code>.</p>
<p>Next lets look at how to load the children for more than one parent record.
<a href="../query_dsl/trait.BelongingToDsl.html#tymethod.belonging_to"><code>belonging_to</code></a> can be used to load the data, but we’ll also need to group it
with its parents. For this we use an additional method <a href="trait.GroupedBy.html#tymethod.grouped_by"><code>grouped_by</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sean = users.filter(name.eq(<span class="string">&quot;Sean&quot;</span>)).first::&lt;User&gt;(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>tess = users.filter(name.eq(<span class="string">&quot;Tess&quot;</span>)).first::&lt;User&gt;(connection)<span class="question-mark">?</span>;

<span class="kw">let </span>seans_posts = Post::belonging_to(<span class="kw-2">&amp;</span>sean)
    .select(title)
    .load::&lt;String&gt;(connection)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">&quot;My first post&quot;</span>, <span class="string">&quot;About Rust&quot;</span>], seans_posts);

<span class="comment">// A vec or slice can be passed as well
</span><span class="kw">let </span>more_posts = Post::belonging_to(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[sean, tess])
    .select(title)
    .load::&lt;String&gt;(connection)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">vec!</span>[<span class="string">&quot;My first post&quot;</span>, <span class="string">&quot;About Rust&quot;</span>, <span class="string">&quot;My first post too&quot;</span>], more_posts);</code></pre></div>
<p>Typically you will want to group up the children with their parents.
In other ORMs, this is often called a <code>has_many</code> relationship.
Diesel provides support for doing this grouping, once the data has been
loaded.</p>
<p><a href="trait.GroupedBy.html#tymethod.grouped_by"><code>grouped_by</code></a> is called on a <code>Vec&lt;Child&gt;</code> with a <code>&amp;[Parent]</code>.
The return value will be <code>Vec&lt;Vec&lt;Child&gt;&gt;</code> indexed to match their parent.
Or to put it another way, the returned data can be passed to <code>zip</code>,
and it will be combined with its parent.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>users = users::table.load::&lt;User&gt;(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>posts = Post::belonging_to(<span class="kw-2">&amp;</span>users)
    .load::&lt;Post&gt;(connection)<span class="question-mark">?
    </span>.grouped_by(<span class="kw-2">&amp;</span>users);
<span class="kw">let </span>data = users.into_iter().zip(posts).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

<span class="kw">let </span>expected_data = <span class="macro">vec!</span>[
    (
        User { id: <span class="number">1</span>, name: <span class="string">&quot;Sean&quot;</span>.into() },
        <span class="macro">vec!</span>[
            Post { id: <span class="number">1</span>, user_id: <span class="number">1</span>, title: <span class="string">&quot;My first post&quot;</span>.into() },
            Post { id: <span class="number">2</span>, user_id: <span class="number">1</span>, title: <span class="string">&quot;About Rust&quot;</span>.into() },
        ],
    ),
    (
        User { id: <span class="number">2</span>, name: <span class="string">&quot;Tess&quot;</span>.into() },
        <span class="macro">vec!</span>[
            Post { id: <span class="number">3</span>, user_id: <span class="number">2</span>, title: <span class="string">&quot;My first post too&quot;</span>.into() },
        ],
    ),
];

<span class="macro">assert_eq!</span>(expected_data, data);</code></pre></div>
<p><a href="trait.GroupedBy.html#tymethod.grouped_by"><code>grouped_by</code></a> can be called multiple times
if you have multiple children or grandchildren.</p>
<p>For example, this code will load some users,
all of their posts,
and all of the comments on those posts.
Explicit type annotations have been added
to make each line a bit more clear.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>users: Vec&lt;User&gt; = users::table.load::&lt;User&gt;(connection)
    .expect(<span class="string">&quot;error loading users&quot;</span>);
<span class="kw">let </span>posts: Vec&lt;Post&gt; = Post::belonging_to(<span class="kw-2">&amp;</span>users)
    .load::&lt;Post&gt;(connection)
    .expect(<span class="string">&quot;error loading posts&quot;</span>);
<span class="kw">let </span>comments: Vec&lt;Comment&gt; = Comment::belonging_to(<span class="kw-2">&amp;</span>posts)
    .load::&lt;Comment&gt;(connection)
    .expect(<span class="string">&quot;Error loading comments&quot;</span>);
<span class="kw">let </span>grouped_comments: Vec&lt;Vec&lt;Comment&gt;&gt; = comments.grouped_by(<span class="kw-2">&amp;</span>posts);
<span class="kw">let </span>posts_and_comments: Vec&lt;Vec&lt;(Post, Vec&lt;Comment&gt;)&gt;&gt; = posts
    .into_iter()
    .zip(grouped_comments)
    .grouped_by(<span class="kw-2">&amp;</span>users);
<span class="kw">let </span>result: Vec&lt;(User, Vec&lt;(Post, Vec&lt;Comment&gt;)&gt;)&gt; = users
    .into_iter()
    .zip(posts_and_comments)
    .collect();
<span class="kw">let </span>expected = <span class="macro">vec!</span>[
    (
        User { id: <span class="number">1</span>, name: <span class="string">&quot;Sean&quot;</span>.to_string() },
        <span class="macro">vec!</span>[
            (
                Post { id: <span class="number">1</span>, user_id: <span class="number">1</span>, title: <span class="string">&quot;My first post&quot;</span>.to_string() },
                <span class="macro">vec!</span>[ Comment { id: <span class="number">1</span>, post_id: <span class="number">1</span>, body: <span class="string">&quot;Great post&quot;</span>.to_string() } ]
            ),
            (
                Post { id: <span class="number">2</span>, user_id: <span class="number">1</span>, title: <span class="string">&quot;About Rust&quot;</span>.to_string() },
                <span class="macro">vec!</span>[
                    Comment { id: <span class="number">2</span>, post_id: <span class="number">2</span>, body: <span class="string">&quot;Yay! I am learning Rust&quot;</span>.to_string() }
                ]

            )
        ]
    ),
    (
        User { id: <span class="number">2</span>, name: <span class="string">&quot;Tess&quot;</span>.to_string() },
        <span class="macro">vec!</span>[
            (
                Post { id: <span class="number">3</span>, user_id: <span class="number">2</span>, title: <span class="string">&quot;My first post too&quot;</span>.to_string() },
                <span class="macro">vec!</span>[ Comment { id: <span class="number">3</span>, post_id: <span class="number">3</span>, body: <span class="string">&quot;I enjoyed your post&quot;</span>.to_string() } ]
            )
        ]
    )
];

<span class="macro">assert_eq!</span>(result, expected);</code></pre></div>
<p>And that’s it.
It may seem odd to have load, group, and zip be explicit separate steps
if you are coming from another ORM.
However, the goal is to provide simple building blocks which can
be used to construct the complex behavior applications need.</p>
</div></details><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.BelongsTo.html" title="diesel::associations::BelongsTo trait">BelongsTo</a></div><div class="item-right docblock-short">Indicates that a type belongs to <code>Parent</code></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GroupedBy.html" title="diesel::associations::GroupedBy trait">GroupedBy</a></div><div class="item-right docblock-short">The <code>grouped_by</code> function groups records by their parent.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.HasTable.html" title="diesel::associations::HasTable trait">HasTable</a></div><div class="item-right docblock-short">This trait indicates that a struct is associated with a single database table.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Identifiable.html" title="diesel::associations::Identifiable trait">Identifiable</a></div><div class="item-right docblock-short">This trait indicates that a struct represents a single row in a database table.</div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.Associations.html" title="diesel::associations::Associations derive">Associations</a></div><div class="item-right docblock-short">Implement required traits for the associations API</div></div><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.Identifiable.html" title="diesel::associations::Identifiable derive">Identifiable</a></div><div class="item-right docblock-short">Implements <code>Identifiable</code> for references of the current type</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="diesel" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-nightly (a6b7274a4 2022-10-10)" ></div></body></html>